# 3P
People, Problem, process
People: 인적자원
Problem: 문제분석과 인식
Process: 전체 계획 및 구조, Framework

# 소프트웨어 재공학
1. 소프트웨어 동작 이해 및 재공학 대상 선정 - 분석(Analysis)
2. 소프트웨어 기능 변경 없이 소프트웨어 형태를 목적에 맞게 수정 - 개조(Restructuring)
3. 원시코드로부터 설계정보 추출 및 절차 설계표현, 프로그램과 데이터 구조 정보 추출 - 역공학(Reversing)
4. 기존 소프트웨어 시스템을 새로운 기술 또는 하드웨어 환경이 이식 - 이식(Migration)

# 객체지향 개념
정보은닉
추상화
캡슐화
상속성
다형성
## 객체지향 개발 과정
분석 단계 : 객체의 이름과 상태, 행위들을 개념적으로 파악한다.
설계 단계 :  객체의 속성과 연산으로 정의하고 접근 방법을 구체화한다.
구현 단계 : 클래스를 비절차적 프로그래밍 언어로 기술한다.
테스트 단계 : 클래스 단위 테스트와 시스템 테스트를 진행한다.


# 소프트웨어 개발단계

# 시스템의 구성요소
process 처리 : 입력된 데이터를 처리 방법과 조건에 따라 처리하는 것
Feedback : 출력된 결과가 예정된 목표를 만족시키지 못할 경우 목표 달성을 위해 반복 처리하는 것
control 제어 : 자료를 입력하여 출력될 때까지의 처리 과정이 올바르게 진행 되는지 감독하는 것
output 출력 : 처리된 결과를 시스템에서 산출하는 것
Input 입력 : 처리방법, 처리할 데이터, 조건을 시스템에 투입하는것

## 유지보수
소프트웨어가 사용자에게 인수되어 설치된 후 발생하는 모든 공학적 작업
- 소프트웨어 유지보수를 용이하게 하려면 시험 용이성, 이해성, 수정용이성, 이식성 등이 고려
### 수정(corrective) 보수 = 수정, 교정, 정정, 하자 보수
- 시스템을 운영하면서 검사 단계에서 발견하지 못한 잠재적인 오류를 찾아 수정하는 활동으로, 오류의 수정과 진단을 포함한다.
### 적응(Adaptive) 보수 - 환경 적응, 조정 보수
- 소프트웨어의 수명 기간 중에 발생하는 환경의 변화를 기존의 소프트웨어에 반영하기 위하여 수행하는 활동
- 운영체제나 컴파일러와 같은 프로그래밍 환경의 변화와 주변장치 또는 다른 시스템 요소가 향상되거나 변경될 때 대처할 수 있는 유지보수 활동이다.
### 완전화(Prefective) 보수
- 소프트웨어의 본래 기능에 새로운 기능을 추가하거나 성능을 개선하기 위해 소프트웨어를 확장시키는 활동
- 유지보수 활동 중 가장 큰 업무 및 비용을 차지하는 활동이다.
### 예방(Preventive) 보수
- 장래의 유지보수성 또는 신뢰성을 개선하거나 소프트웨어의 오류발생에 대비하여 미리 예방 수단을 강구해 두는 활동
예방 유지보수를 **소프트웨어 재공학**이라고도 한다.


# 자료흐름도 DFD 
Process : 원
Data Flow : 화살표
Data Store : 두글자 직선
Terminator : 사각형


# 자료사전 Data Dictionary
	<문제 해설>
= : 자료의 정의
+ : 자료의 연결
() : 자료의 생략
{} : 자료의 반복
| : 자료의 선택
** : 자료의 설명

# 소프트웨어 생명주기 모형
## spiral model 나선형모형
-점진적으로 완벽한 최종 소프트웨어를 개발
-대규모시스템에 적합
-계획 및 정의-위험분석-개발-고객평가 (유지보수X)
## waterfall model 폭포수 모형
소프트웨어 생명주기 모형 중 Bohem이 제시한 고전적 생명주기 모형으로서 선형 순차적 모델이라고도 함
타당성 검토, 계획, 요구사항 분석, 설계, 구현, 테스트, 유지보수의 단계
## prototype model 프로토타입 모형
사용자의 요구사항을 정확히 파악하기위해 최종결과물의 일부또는 모형을 볼 수있는 타입
요구수집-빠른설계-프로토타입 구축-고객평가-프로토타입 조정-구현

### 프로토타입 모형의 장점
- 요구사항을 충실히 반영하며, 요구사항의 변경이 용이하다.
- 최종 결과물이 만들어지기 전에 의뢰자가 최종 결과물의 일부 또는 모형을 볼 수 있다.
- 프로토타입은 의뢰자나 개발자 모두에게 공동의 참조 모델을 제공한다.

### 프로토타입 모형의 단점
- 미리 제작된 소프트웨어를 사용할 경우 실제 소프트웨어와의 차이가 발생할 수 있어 사용자에게 혼란을 줄 수 있다.
- 단기간에 제작해야 하기 때문에 비효율적인 언어나 알고리즘을 사용할 수 있다.

# 결합도
자료결합도->스탬프결합도(stamp)->제어(control)->외부->공통(common)->내용결합도(content coupling)
결합도가 낮을수록 독립적인 모듈

# 응집력

# 소프트웨어 재사용
소프트웨어 재사용함으로써 얻을 수 있는 이점들
1. 개발 시간과 비용 단축
2. 소프트웨어 품질 및 생산성 향상
3. 프로젝트 실패 위험 감소
4. 시스템 구축 방법에 대한 지식 공유


소프트웨어 재사용함으로써 얻을 수 있는 문제점들
1. 재사용할 소프트 웨어 선정 필요
2. 시스템에 공통적으로 사용되는 요소 발견 필요
3. 프로그램의 표준화 부족
4. 새로운 개발 방법론 도입이 어려움
5. 재사용을 위한 관리 및 지원 부족
6. 기존 소프트웨어에 재사용 소프트웨어를 추가하기 어려움

# 럼바우의 객체지향 분석
- 객체 모델링 : 객체들 간의 관계를 규정하여 표현
- 동적 모델링 : 상태도를 이용
- 기능 모델링 : 자료 흐름도를 이용
## 럼바우 분석기법에 대한 이용
-기능모델링 : DFD(자료흐름도)
-동적모델링 : 상태도
-객체모델링 : 클래스(객체) 다이어램


# CASE(Computer Aided Software Engineering)
1.	프로그램의 구현과 유지보수 작업만을 중심으로 하는 것이 아니라 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 자동화하는 것
2.	소프트웨어 생명주기의 전체 단계를 연결해 주고 자동화해 주는 통합된 도구를 제공한다.
3.	개발 과정의 속도를 향상시킨다.
4.	소프트웨어 부품의 재사용을 가능하게 한다.

CASE의 주요기능은 소프트웨어 생명주기 전 단계의 연결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원 등이 있습니다.
CASE의 사용의 이점은 소프트웨어 개발 기간 단축 및 비용 절감(1번보기), 유지보수가 용이하고 품질과 생산성, 재사용성 향상.(3번보기), 개발 주기의 표준화(4번보기), 개발 기법의 실용화, 문서화 용이 등의 이점이 있습니다.

# 비용산정기법
## Effort Per Task기법
## 전문가 감정 기법
## 델파이기법
## LOC기법
line of code
S/W 각 기능의 원시 코드 라인수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법
## COCOMO
Loc + 소프트웨어 종류에 따라 비용산정
개발 유형으로 organic, semi-detach, embedded로 구분되는 것
Organic projects : 엄격하지 않은 요구사항에 대한 좋은 작업 경험을 가진 작은 팀
Semi-detached projects : 엄격하지 않은 요구사항과 다양한 요구사항에 대해 다양한 작업 경험을 가진 중간 팀
Embedded projects : 타이트한 제약조건 속에서 발전되어온 팀. organic 과 semi-detached 프로젝트가 결합됐다.
COCOMO(constructive cost model)
1. 유기형(organic): 일괄처리나 과학기술 계산용, 비즈니스 자료 처리용의 5만 라인 이하의 소프트웨어를 평가
2. 준 분리형(semi-detached): 트랜잭션 처리 시스템이나 운영체제, 데이터베이스 관리 시스템 등의 30만 라인 이하의 소프트웨어를 평가
3. 내재형(embedded): 최대형 규모의 트랜잭션 시스템이나 운영체제 등의 30만 라인 이상의 소프트웨어를 평가

# 테스트
## 화이트박스 테스트
## 블랙박스 테스트
블랙박스의 경우 입력과 출력(결과)만이 알 수 있다.
"조건, 흐름, 루프 내" 등과 같이 중간요소를 언급하는 단어가
나오면 화이트 박스의 역할이다.

# 소프트웨어 품질 목표
신뢰성 Reliability : 요구된 기능을 얼마나 오류없이 정확하게 실행할 수 있는가
이식성 Portability : 다양한 하드웨어에서 운용 가능 하도록 쉽게 수정할 수 있는가
정확성 Correctness : 사용자가 요구한 기능을 얼마나 충족시키는가
효율성 Efficiency  : 얼마나 많은 자원이 필요한가 (필요한 자원의 정도)
무결성(Integrity) : 허용되지 않은 사용이나 자료의 변경을 제어하는 정도. 따라서 일관된 결과와 옳은 결과를 얻고 요구 기능 수행할 수 있는 정도이므로 신뢰성.
정확성, 신뢰성, 효율성, 무결성, 유연성, 이식성, 재사용성, 상호운용성이 있다.
(최적화, 중복성, 간결성, 종석성, 복잡성이 함정으로 많이 출제된다)

# 브룩스(Brooks)의 법칙
- 프로젝트 진행중에 새로운 인력을 투입할 경우 작업 적응 기간과 부작용으로 인해 일정을 더욱 지연시키고, 프로젝트에 혼란을 가져오게 된다는 법칙

# 소프트웨어 구조
fan-in : 어떤 모듈을 제어하는 상위 모듈 수로 한 노드로 들어오는 화살표 수
fan-out : 한 노드로부터 나가는 화살표 수
-공유도 (Fan-In) : 어떤 모듈을 제어(호출)하는 상위 모듈의 개수
-제어도 (Fan-out) : 어떤 모듈에 의해 제어(호출)되는 하위 모듈의 개수

